// eoa-quick-test.ts
//
// This script automates the process of creating an Email on Acid email test,
// polling for its results until all specified clients have either completed
// or failed their preview generation, and then saving only the
// 'default' screenshot URL for each completed target client into a JSON file.
//
// THIS VERSION CONTAINS REFINED LOGIC FOR URL EXTRACTION AND MORE FOCUSED DEBUGGING.
//
// Current Date/Time in Buenos Aires: Friday, July 25, 2025 at 3:41:08 PM -03.

import axios from 'axios';
import * as dotenv from 'dotenv';
import { readFileSync, writeFileSync } from 'fs';
import { resolve } from 'path';

// Load environment variables from .env file
dotenv.config();

/**
 * Helper function to generate the HTTP Basic Authentication header string.
 * Email on Acid API v5 uses Basic Authentication where the username is your API Key
 * and the password is your Account Password. These are base64 encoded.
 * @param apiKey Your Email on Acid API Key.
 * @param accountPassword Your Email on Acid Account Password.
 * @returns The Basic Authorization header string (e.g., "Basic <base64_credentials>").
 */
function getBasicAuthHeader(apiKey: string, accountPassword: string): string {
  const credentials = Buffer.from(`${apiKey}:${accountPassword}`).toString('base64');
  return `Basic ${credentials}`;
}

/**
 * Main function to perform the Email on Acid API test sequence:
 * 1. Read email HTML content.
 * 2. Create a new email test on Email on Acid for specified clients.
 * 3. Poll the API for test results until all target clients are processed (complete or failed).
 * 4. Extract and save only the default screenshot URL for each *completed* client to a JSON file.
 */
async function runEmailOnAcidQuickTest(): Promise<void> {
  // --- Configuration from Environment Variables and File System ---
  const apiKey = process.env.EMAILONACID_API_KEY;
  const accountPassword = process.env.EMAILONACID_ACCOUNT_PASSWORD;
  const emailHtmlFilePath = resolve(__dirname, 'email.html'); // Path to the HTML content for the email test
  const outputJsonFilePath = resolve(__dirname, 'eoa-preview-urls.json'); // Output file for just the URLs

  // Define the specific email client IDs for which we want to create tests and retrieve results.
  // These IDs must exactly match what Email on Acid API expects (e.g., from /v5/email/clients).
  const targetClients = ["applemail16_dm", "m365_w11_dm_dt"];
  const apiBaseUrl = 'https://api.emailonacid.com/v5'; // Base URL for EOA API v5

  // --- 1. Input Validation: Check Credentials and HTML File ---
  if (!apiKey || !accountPassword) {
    console.error('Error: EMAILONACID_API_KEY and EMAILONACID_ACCOUNT_PASSWORD must be set in your .env file.');
    console.error('Please ensure these credentials are provided for authentication.');
    process.exit(1); // Exit with an error code if credentials are missing
  }

  let emailHtmlContent: string;
  try {
    emailHtmlContent = readFileSync(emailHtmlFilePath, 'utf-8');
    console.log(`Successfully read HTML content from: ${emailHtmlFilePath}`);
  } catch (error: any) {
    console.error(`Error: Could not read email HTML file at ${emailHtmlFilePath}.`);
    console.error(`Please ensure 'email.html' exists in the project root: ${emailHtmlFilePath}`);
    process.exit(1); // Exit if the HTML file cannot be read
  }

  // --- Prepare Authentication Headers for Axios Requests ---
  const authHeaders = {
    'Authorization': getBasicAuthHeader(apiKey, accountPassword),
    'Content-Type': 'application/json', // Required for POST requests with JSON payload
    'Accept': 'application/json',       // Indicates client prefers JSON responses
  };

  let testId: string | undefined; // Variable to store the unique test ID generated by EOA
  // Generate a dynamic subject line including current time for easy identification in EOA dashboard
  const testSubject = `Quick Test (Apple/M365 DM) - ${new Date().toLocaleString('en-US', { timeZone: 'America/Argentina/Buenos_Aires' })}`;

  // --- 2. POST /v5/email/tests: Create a New Email Test ---
  console.log('\n--- Step 1: Creating Email Test on Email on Acid ---');
  try {
    const createTestPayload = {
      subject: testSubject,
      html: emailHtmlContent,
      clients: targetClients, // Pass the array of desired client IDs for the test
      // sandbox: true, // Uncomment if you have a sandbox environment configured and want to use it
    };
    
    console.log('Sending request to create test for clients:', targetClients.join(', '));
    const response = await axios.post(`${apiBaseUrl}/email/tests`, createTestPayload, { headers: authHeaders });
    
    testId = response.data?.id; // Extract the test ID from the API response
    if (!testId) {
      throw new Error('Email on Acid API did not return a valid test ID in the response.');
    }
    console.log(`Email test created successfully. Test ID: ${testId}`);
    console.log(`Check your Email on Acid dashboard for test progress: https://app.emailonacid.com/tests/${testId}/previews`);

  } catch (error: any) {
    console.error('Error creating email test:', error.message);
    if (axios.isAxiosError(error) && error.response) {
      // Log more details for Axios errors (HTTP status, response data)
      console.error('API Response Status:', error.response.status);
      console.error('API Response Data:', JSON.stringify(error.response.data, null, 2));
    }
    process.exit(1); // Abort if test creation fails
  }

  // --- 3. GET /v5/email/tests/<test_id>/results: Poll for Test Results ---
  console.log('\n--- Step 2: Polling for Test Results ---');
  // This object will store only the default screenshot URLs for completed clients.
  const extractedUrls: Record<string, string> = {}; 
  
  const MAX_POLLING_ATTEMPTS = 60; // Max attempts (60 attempts * 10 seconds = 10 minutes max wait)
  const POLLING_INTERVAL_MS = 10000; // Wait 10 seconds between each polling attempt

  // Keep track of the actual client results retrieved from the API to check their status
  // This will be an object mapping client_id to its result object, similar to the API response.
  let currentApiResults: Record<string, any> = {}; 

  for (let attempt = 0; attempt < MAX_POLLING_ATTEMPTS; attempt++) {
    let allTargetClientsProcessedInThisAttempt = true; // Assume all are processed until proven otherwise

    try {
      console.log(`\n  --- Polling Attempt ${attempt + 1}/${MAX_POLLING_ATTEMPTS} ---`);
      console.log(`  Fetching results for Test ID ${testId}...`);
      const response = await axios.get(`${apiBaseUrl}/email/tests/${testId}/results`, { headers: authHeaders });
      
      // *** THE CRITICAL CHANGE IS HERE: DIRECTLY USE response.data AS THE CLIENT MAP ***
      currentApiResults = response.data || {}; // Response is an object where keys are client IDs

      // --- DEBUG: Log the keys (client IDs) received in this response ---
      console.log(`  DEBUG: API Response contains results for clients: [${Object.keys(currentApiResults).join(', ')}]`);
      // --- End Debug ---

      // Check if any results are actually returned yet for our target clients.
      // If we don't have all target clients present in the response yet, we must keep polling.
      const clientsPresentInResponse = Object.keys(currentApiResults).filter(id => targetClients.includes(id)).length;
      if (clientsPresentInResponse < targetClients.length) {
          allTargetClientsProcessedInThisAttempt = false; // Not all target clients are even in the response yet
          console.log(`    DEBUG: Not all target clients are present in the current API response. Continuing to poll.`);
      }

      // Iterate through the *desired* target clients to check their status and extract URLs
      for (const targetClientId of targetClients) {
        const clientResult = currentApiResults[targetClientId]; // Access client data directly by ID

        if (!clientResult) {
          // This target client is not yet in the results object, so we need to continue polling.
          allTargetClientsProcessedInThisAttempt = false; 
          console.log(`    DEBUG: Target client "${targetClientId}" not found in current API results object. Continuing to poll.`);
          continue; // Move to next target client
        }

        // --- DEBUG: Comprehensive Debugging for clientResult and URL extraction ---
        // console.log(`\n    DEBUG: Processing client: "${targetClientId}"`);
        // console.log(`      Current Status: ${clientResult.status}`);
        // console.log(`      Client screenshots object: ${JSON.stringify(clientResult.screenshots, null, 2)}`);
        // console.log(`      Value of clientResult.screenshots?.default: ${clientResult.screenshots?.default}`);
        // console.log(`      Type of clientResult.screenshots?.default: ${typeof clientResult.screenshots?.default}`);
        // --- End Debugging ---

        // Check the status of the found client result
        if (clientResult.status === 'Complete') { // Note: EOA status can be 'Complete' (capital C)
          // Client is complete. Extract and store ONLY the default screenshot URL.
          // We now ALWAYS attempt to set the URL if it's valid, overwriting previous values if needed.
          if (clientResult.screenshots?.default && typeof clientResult.screenshots.default === 'string') {
            if (extractedUrls[targetClientId] !== clientResult.screenshots.default) {
                extractedUrls[targetClientId] = clientResult.screenshots.default;
                console.log(`    SUCCESS: Stored/Updated URL for "${targetClientId}": ${extractedUrls[targetClientId]}`);
            } else {
                console.log(`    INFO: URL for "${targetClientId}" already captured and is the same. No update needed.`);
            }
          } else {
            // Client is complete, but the URL is missing or not a string. This is an unexpected state.
            console.warn(`    WARNING: Client "${targetClientId}" is 'Complete', but default screenshot URL is missing or invalid. Value: ${clientResult.screenshots?.default}`);
            // Since the URL isn't valid yet, we still consider this client as not fully processed for a URL.
            allTargetClientsProcessedInThisAttempt = false; 
          }
        } else if (clientResult.status === 'Failed' || clientResult.status === 'Bounced') { // Also handle 'Bounced' status
          // Client failed or bounced. We consider it processed for the purpose of stopping polling for *this* client.
          // We do NOT store a URL for failed/bounced clients in the final output as per requirements.
          if (!extractedUrls[targetClientId]) { // Log failure only if we haven't already marked it as complete
            console.warn(`    FAILED: Client "${targetClientId}" status: ${clientResult.status}. Error: ${clientResult.status_details?.bounce_message || clientResult.error_message || 'No specific error message provided.'}`);
          }
        } else { // Status is 'Processing', 'Pending', or something else not final.
          // Client is still pending, so we need to continue polling overall.
          allTargetClientsProcessedInThisAttempt = false;
          console.log(`    Client "${targetClientId}" is still "${clientResult.status}". Continuing to poll.`);
        }
      }

      // Check if all desired clients have been processed (complete or failed/bounced).
      // We check the *currentApiResults* to see how many of our target clients have reached a final state.
      const finalStatusesCount = targetClients.filter(id => {
          const clientData = currentApiResults[id];
          return clientData && (clientData.status === 'Complete' || clientData.status === 'Failed' || clientData.status === 'Bounced');
      }).length;

      if (finalStatusesCount === targetClients.length) {
        console.log('\n  All desired client previews have reached a final status (Complete, Failed, or Bounced)! Exiting polling loop.');
        break; // Exit polling loop as we have all necessary data or confirmed failures
      } else {
        const extractedCount = Object.keys(extractedUrls).length;
        const remainingToProcess = targetClients.filter(id => {
            const clientData = currentApiResults[id];
            // Remaining if not in response OR status is not final
            return !clientData || (clientData.status !== 'Complete' && clientData.status !== 'Failed' && clientData.status !== 'Bounced');
        });
        console.log(`  Overall Progress: ${extractedCount} URLs successfully extracted. ${remainingToProcess.length} clients still pending/not in final state: [${remainingToProcess.join(', ')}]`);
      }

    } catch (error: any) {
      if (axios.isAxiosError(error) && error.response) {
        if (error.response.status === 404) {
          console.warn(`  Polling error: Test results for ${testId} not yet available (404 Not Found). Retrying...`);
          // This doesn't mean all are processed, so continue polling.
          allTargetClientsProcessedInThisAttempt = false; 
        } else if (error.response.status === 401) {
          console.error("  Polling error: Authentication failed. Please check API Key and Account Password.");
          process.exit(1); 
        } else {
          console.warn(`  Polling error, status ${error.response.status}: ${error.message}. API Response Data: ${JSON.stringify(error.response.data, null, 2)}`);
          // If there's an API error, we assume we need to retry.
          allTargetClientsProcessedInThisAttempt = false; 
        }
      } else {
        console.warn(`  Network or unexpected error during polling: ${error.message}. Retrying...`);
        allTargetClientsProcessedInThisAttempt = false; 
      }
    }

    // Only wait if it's not the last attempt AND we are still waiting for results to finalize
    // The `allTargetClientsProcessedInThisAttempt` flag is the key to deciding if we need to wait more.
    if (attempt < MAX_POLLING_ATTEMPTS - 1 && !allTargetClientsProcessedInThisAttempt) {
      await new Promise(resolve => setTimeout(resolve, POLLING_INTERVAL_MS));
    }
  }

  // --- Final Check and Reporting ---
  if (Object.keys(extractedUrls).length === 0) {
    console.warn(`\n--- FINAL RESULT: NO URLs RETRIEVED ---`);
    console.warn(`No completed preview URLs were retrieved for test ID ${testId} after ${MAX_POLLING_ATTEMPTS} attempts.`);
    console.warn('This might indicate that all target clients failed to generate previews, or the test itself is problematic.');
  } else if (Object.keys(extractedUrls).length < targetClients.length) {
    console.warn(`\n--- FINAL RESULT: PARTIAL URLs RETRIEVED ---`);
    console.warn(`Only ${Object.keys(extractedUrls).length} of ${targetClients.length} desired client previews completed and had URLs.`);
    const missingClients = targetClients.filter(id => !extractedUrls[id]);
    console.warn(`The following clients were expected but did not complete or did not provide a default screenshot URL: [${missingClients.join(', ')}]`);
  } else {
    console.log('\n--- FINAL RESULT: ALL DESIRED URLs EXTRACTED ---');
  }

  // For quick inspection, log the final URLs
  console.log('\nExtracted URLs:');
  for (const clientId in extractedUrls) {
      console.log(`  ${clientId}: ${extractedUrls[clientId]}`);
  }

  // --- 4. Save Extracted URLs to a JSON file ---
  console.log('\n--- Step 4: Saving Extracted URLs to File ---');
  try {
    writeFileSync(outputJsonFilePath, JSON.stringify(extractedUrls, null, 2), 'utf-8');
    console.log(`Successfully saved extracted URLs to: ${outputJsonFilePath}`);
  } catch (error: any) {
    console.error(`Error saving URLs to file ${outputJsonFilePath}:`, error.message);
    process.exit(1);
  }

  console.log('\n--- Quick Test Complete ---');
}

// Execute the main function
runEmailOnAcidQuickTest();